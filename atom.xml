<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Z.H.Chen&#39;s Blog</title>
  <icon>https://aishangcengloua.github.io/icon.png</icon>
  
  <link href="https://aishangcengloua.github.io/atom.xml" rel="self"/>
  
  <link href="https://aishangcengloua.github.io/"/>
  <updated>2022-06-05T11:46:14.292Z</updated>
  <id>https://aishangcengloua.github.io/</id>
  
  <author>
    <name>Z.H.Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PyTorch——实现自注意力机制（self-attention）</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/PyTorch%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%88self-attention%EF%BC%89/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/PyTorch%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%EF%BC%88self-attention%EF%BC%89/</id>
    <published>2022-06-05T11:45:21.000Z</published>
    <updated>2022-06-05T11:46:14.292Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-原理简述&quot;&gt;&lt;a href=&quot;#1-原理简述&quot; class=&quot;headerlink&quot; title=&quot;1    原理简述&quot;&gt;&lt;/a&gt;1    原理简述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Self-Attention Layer 一次检查同一句子中的所有单词的注意力，这使得它成为一个简单的矩阵计算，并且能够在计算单元上并行计算。 此外，Self-Attention Layer 可以使用下面提到的 Multi-Head 架构来拓宽视野，也就是多头注意力机制。Self-Attention Layer 基本结构如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/fc65b9f0024549318aad9019931c293a.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="PyTorch" scheme="https://aishangcengloua.github.io/tags/PyTorch/"/>
    
    <category term="self-attention" scheme="https://aishangcengloua.github.io/tags/self-attention/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读：Pseudo-Label : The Simple and Efficient Semi-Supervised Learning Method for Deep Neural Network</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9APseudo-Label-The-Simple-and-Efficient-Semi-Supervised-Learning-Method-for-Deep-Neural-Network/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9APseudo-Label-The-Simple-and-Efficient-Semi-Supervised-Learning-Method-for-Deep-Neural-Network/</id>
    <published>2022-06-05T11:40:32.000Z</published>
    <updated>2022-06-05T11:44:54.686Z</updated>
    
    
    <summary type="html">&lt;center&gt;&lt;font size=&quot;6&quot;&gt;&lt;font color=&quot;red&quot;&gt;论文阅读：Pseudo-Label : The Simple and Efficient Semi-Supervised Learning Method for Deep Neural Networks&lt;/font&gt;&lt;/font&gt;&lt;/center&gt;

&lt;h1 id=&quot;1-文章简述&quot;&gt;&lt;a href=&quot;#1-文章简述&quot; class=&quot;headerlink&quot; title=&quot;1    文章简述&quot;&gt;&lt;/a&gt;1    文章简述&lt;/h1&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="自监督学习" scheme="https://aishangcengloua.github.io/tags/%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文阅读" scheme="https://aishangcengloua.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MTCNN 测试时的一些 tips</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/MTCNN-%E6%B5%8B%E8%AF%95%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B-tips/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/MTCNN-%E6%B5%8B%E8%AF%95%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B-tips/</id>
    <published>2022-06-05T11:31:30.000Z</published>
    <updated>2022-06-05T11:39:53.542Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-网络结构&quot;&gt;&lt;a href=&quot;#1-网络结构&quot; class=&quot;headerlink&quot; title=&quot;1    网络结构&quot;&gt;&lt;/a&gt;1    网络结构&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;MTCNN 是多任务级联 CNN 的人脸检测深度学习模型，该模型不仅考虑了人脸检测概率，还综合训练了人脸边框回归和面部关键点检测，多任务同时建立 loss function 并训练，因此为 MTCNN。级联 CNN 主要由三个子网络组成：P-Net、R-Net 和 O-Net。&lt;br&gt;&amp;emsp;&amp;emsp;P-Net 的结构如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/52bf5bf680944505ad1a4f52c5a94644.png#pic_center&quot; alt=&quot;在这里插入图片描述\](https://img-blog.csdnimg.cn/a37a2812f2914fd48ae0c9f7ed16cb35.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="PyTorch" scheme="https://aishangcengloua.github.io/tags/PyTorch/"/>
    
    <category term="人脸检测" scheme="https://aishangcengloua.github.io/tags/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    
    <category term="MTCNN" scheme="https://aishangcengloua.github.io/tags/MTCNN/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的图：A* 算法</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/Python-%E4%B8%AD%E7%9A%84%E5%9B%BE%EF%BC%9AA-%E7%AE%97%E6%B3%95/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/Python-%E4%B8%AD%E7%9A%84%E5%9B%BE%EF%BC%9AA-%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-05T11:29:16.000Z</published>
    <updated>2022-06-05T11:30:36.563Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-什么是A-算法&quot;&gt;&lt;a href=&quot;#1-什么是A-算法&quot; class=&quot;headerlink&quot; title=&quot;1    什么是A*算法&quot;&gt;&lt;/a&gt;1    什么是A*算法&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;假设一个走迷宫游戏，我将 &lt;strong&gt;A&lt;/strong&gt; 点定义成起点也就是开始状态，定义 &lt;strong&gt;B&lt;/strong&gt; 为终点也就是结束状态。我们的目标就是找到从 A 走到 B 地最佳路径，如下图所示：&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://aishangcengloua.github.io/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/tags/Python/"/>
    
    <category term="图" scheme="https://aishangcengloua.github.io/tags/%E5%9B%BE/"/>
    
    <category term="A*" scheme="https://aishangcengloua.github.io/tags/A/"/>
    
    <category term="启发式函数" scheme="https://aishangcengloua.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题——字符串</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/LeetCode%E5%88%B7%E9%A2%98%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-06-05T11:27:27.000Z</published>
    <updated>2022-06-05T11:28:39.286Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;344. 反转字符串&quot;&gt;&lt;/a&gt;344. 反转字符串&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 &lt;code&gt;s&lt;/code&gt; 的形式给出。不要给另外的数组分配额外的空间，你必须&lt;strong&gt;原地修改输入数组&lt;/strong&gt;、使用 &lt;code&gt;O(1)&lt;/code&gt; 的额外空间解决这一问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://aishangcengloua.github.io/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/tags/Python/"/>
    
    <category term="字符串" scheme="https://aishangcengloua.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的图：图的存储结构</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/Python-%E4%B8%AD%E7%9A%84%E5%9B%BE%EF%BC%9A%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/Python-%E4%B8%AD%E7%9A%84%E5%9B%BE%EF%BC%9A%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</id>
    <published>2022-06-05T11:25:53.000Z</published>
    <updated>2022-06-05T11:26:48.596Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-什么是图&quot;&gt;&lt;a href=&quot;#1-什么是图&quot; class=&quot;headerlink&quot; title=&quot;1    什么是图&quot;&gt;&lt;/a&gt;1    什么是图&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;图是一种数据结构，可用于对对象之间的层次结构和关系进行建模。它由&lt;strong&gt;一组节点&lt;/strong&gt;和&lt;strong&gt;一组边&lt;/strong&gt;组成。节点表示单个对象，而边表示这些对象之间的关系。&lt;strong&gt;注意&lt;/strong&gt;：可能在不同的文献中节点也被称作&lt;strong&gt;顶点&lt;/strong&gt;，它们指同一个意思。&lt;br&gt;&amp;emsp;&amp;emsp;如果图中的边可以通过双向遍历，则是&lt;strong&gt;无向图(undirected)&lt;/strong&gt;，如果只能通过一个方向进行遍历，则是&lt;strong&gt;有向图(undirected)&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2b04ebe1cbfb4c40b1634dde5bbcbb67.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;并非图的所有节点都需要与其他节点连接。如果可以从图中的每个节点 访问其他任何的节点，我们称该图为&lt;strong&gt;连接图(connected)&lt;/strong&gt;，但有时你通过一些几点无法访问其他节点，那这个图就是&lt;strong&gt;未连接图(disconnected)&lt;/strong&gt;。常见的误解是图的节点之间都必须连接，事实上，图可以不包含边，只有节点：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/1924b974e53047c992477123b99185a0.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;从实现的角度来看，在定义好节点之后，我们需要定义是&lt;strong&gt;边缘的权重(weights)&lt;/strong&gt;。它是分配给边缘的数值，描述了遍历该边缘的成本。边的权重越小，遍历它的成本就越低。基于此，将权重分配给边缘的图称为&lt;strong&gt;加权图&lt;/strong&gt;：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/15925167fb9c48648c311f39b2eebc80.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://aishangcengloua.github.io/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/tags/Python/"/>
    
    <category term="图" scheme="https://aishangcengloua.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——哈希表经典例题</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/LeetCode%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/LeetCode%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/</id>
    <published>2022-06-05T11:24:17.000Z</published>
    <updated>2022-06-05T11:25:26.865Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;242-有效的字母异位词&quot;&gt;&lt;a href=&quot;#242-有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;242. 有效的字母异位词&quot;&gt;&lt;/a&gt;242. 有效的字母异位词&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。&lt;br&gt;示例 1:&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://aishangcengloua.github.io/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/tags/Python/"/>
    
    <category term="哈希表" scheme="https://aishangcengloua.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的图：Dijkstra 算法</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/Python-%E4%B8%AD%E7%9A%84%E5%9B%BE%EF%BC%9ADijkstra-%E7%AE%97%E6%B3%95/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/Python-%E4%B8%AD%E7%9A%84%E5%9B%BE%EF%BC%9ADijkstra-%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-05T11:22:31.000Z</published>
    <updated>2022-06-05T11:23:34.196Z</updated>
    
    
    <summary type="html">&lt;p&gt;﻿## 介绍&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;图是最有用的数据结构之一。它们可用于对几乎所有事物进行建模——对象关系和网络是最常见的。图像可以表示为网格状的像素图，句子可以表示为单词的图。图表被用于各个领域，从制图到社会心理学，当然它们在计算机科学中也被广泛使用。因此图搜索和遍历起着重要的计算作用。&lt;strong&gt;Dijkstra 算法&lt;/strong&gt;旨在找到 &lt;strong&gt;图中节点&lt;/strong&gt; 之间的最短路径。它是由荷兰计算机科学家 Edsger Wybe Dijkstra 于 1956 年在思考从鹿特丹到格罗宁根的最短路线时设计的。&lt;strong&gt;Dijkstra 算法&lt;/strong&gt; 多年来一直在发生变化，并且存在各种版本和变体。最初用于计算两个节点之间的最短路径。由于它的工作方式 ，适用于计算起始节点和图中每个其他节点之间的最短路径。这种方式可用于生成 &lt;strong&gt;最短路径树&lt;/strong&gt;，该树由两个节点以及所有其他节点之间的最短路径组成。然后你可以修剪掉你不感兴趣的树，得到两个节点之间的最短路径，但你不可避免地必须计算整个树，这是 &lt;strong&gt;Dijkstra 算法&lt;/strong&gt; 的一个缺点，它不适合大型图。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://aishangcengloua.github.io/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/tags/Python/"/>
    
    <category term="Dijkstra" scheme="https://aishangcengloua.github.io/tags/Dijkstra/"/>
    
    <category term="图" scheme="https://aishangcengloua.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>【Opencv】目标追踪——高斯混合模型分离算法(MOG)</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E3%80%90Opencv%E3%80%91%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA%E2%80%94%E2%80%94%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E5%88%86%E7%A6%BB%E7%AE%97%E6%B3%95-MOG/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E3%80%90Opencv%E3%80%91%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA%E2%80%94%E2%80%94%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E5%88%86%E7%A6%BB%E7%AE%97%E6%B3%95-MOG/</id>
    <published>2022-06-05T11:21:02.000Z</published>
    <updated>2022-06-05T11:21:48.677Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1    环境&quot;&gt;&lt;/a&gt;1    环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Python 3.8.8&lt;/li&gt;
&lt;li&gt;PyCharm 2021&lt;/li&gt;
&lt;li&gt;opencv-python&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器视觉" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="opencv" scheme="https://aishangcengloua.github.io/tags/opencv/"/>
    
    <category term="目标追踪" scheme="https://aishangcengloua.github.io/tags/%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>优化算法</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-05T11:19:17.000Z</published>
    <updated>2022-06-05T11:20:02.378Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在机器学习模型中，我们会使用损失函数对模型的输出和标注信息计算他们之间的差异，然后使用损失进行反向传播，在反向传播中，我们的目的是不断地更新参数使得模型损失越来越小直至达到最小，这过程是优化参数的过程，基础的优化算法是使用梯度下降法(如下图)，梯度下降法利用了梯度的反方向是函数下降最快的方向的特性，该过程可以理解成寻找山谷。随后为了提高效率和准确率许多的改进的优化算法被提出，下面我们将介绍几种常用的优化算法。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>激活函数</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</id>
    <published>2022-06-05T11:17:36.000Z</published>
    <updated>2022-06-05T11:18:39.615Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1    定义&quot;&gt;&lt;/a&gt;1    定义&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;激活函数 (&lt;strong&gt;&lt;em&gt;Activation functions&lt;/em&gt;&lt;/strong&gt;) 对于人工神经网络模型去学习、理解非常复杂和非线性的函数来说具有十分重要的作用。它们将非线性特性引入到神经网络中。在下图中，输入的 inputs 通过加权，求和后，还被作用了一个函数，这个函数就是激活函数。引入激活函数是为了增加神经网络模型的非线性。没有激活函数的每层都相当于矩阵相乘。就算你叠加了若干层之后，无非还是个矩阵相乘罢了。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2076a4e3b2ad4eac9c75c74ffbcb8ede.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【Opencv】图像分割——区域生长</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E3%80%90Opencv%E3%80%91%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E3%80%90Opencv%E3%80%91%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/</id>
    <published>2022-06-05T11:15:31.000Z</published>
    <updated>2022-06-05T11:16:20.894Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1    环境&quot;&gt;&lt;/a&gt;1    环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Python 3.8.8&lt;/li&gt;
&lt;li&gt;PyCharm 2021&lt;/li&gt;
&lt;li&gt;opencv-python&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器视觉" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="opencv" scheme="https://aishangcengloua.github.io/tags/opencv/"/>
    
    <category term="图像分割" scheme="https://aishangcengloua.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>【Opencv】图像分割——区域分裂合并</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E3%80%90Opencv%E3%80%91%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E5%88%86%E8%A3%82%E5%90%88%E5%B9%B6/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E3%80%90Opencv%E3%80%91%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E5%88%86%E8%A3%82%E5%90%88%E5%B9%B6/</id>
    <published>2022-06-05T11:14:07.000Z</published>
    <updated>2022-06-05T11:16:40.137Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1    环境&quot;&gt;&lt;/a&gt;1    环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Python 3.8.8&lt;/li&gt;
&lt;li&gt;PyCharm 2021&lt;/li&gt;
&lt;li&gt;opencv-python&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器视觉" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="opencv" scheme="https://aishangcengloua.github.io/tags/opencv/"/>
    
    <category term="图像分割" scheme="https://aishangcengloua.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——二叉树的前中后序遍历</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/LeetCode%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/LeetCode%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-06-05T11:10:54.000Z</published>
    <updated>2022-06-05T11:12:38.185Z</updated>
    
    
    <summary type="html">&lt;p&gt;﻿二叉树主要有两种遍历方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度优先遍历：先往深走，遇到叶子节点再往回走。&lt;/li&gt;
&lt;li&gt;广度优先遍历：一层一层的去遍历，也就是常说的层遍历。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://aishangcengloua.github.io/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="https://aishangcengloua.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="Python" scheme="https://aishangcengloua.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【OpenCv】图像分割——聚类算法</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E3%80%90OpenCv%E3%80%91%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E3%80%90OpenCv%E3%80%91%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-05T11:09:27.000Z</published>
    <updated>2022-06-05T11:10:21.098Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1    原理&quot;&gt;&lt;/a&gt;1    原理&lt;/h1&gt;&lt;p&gt;KMeans算法概述&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器视觉" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="聚类" scheme="https://aishangcengloua.github.io/tags/%E8%81%9A%E7%B1%BB/"/>
    
    <category term="opencv" scheme="https://aishangcengloua.github.io/tags/opencv/"/>
    
    <category term="图像分割" scheme="https://aishangcengloua.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>【OpenCv】图像分割——分水岭算法</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E3%80%90OpenCv%E3%80%91%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%88%86%E6%B0%B4%E5%B2%AD%E7%AE%97%E6%B3%95/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E3%80%90OpenCv%E3%80%91%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%88%86%E6%B0%B4%E5%B2%AD%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-05T11:07:56.000Z</published>
    <updated>2022-06-05T11:08:50.551Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1    原理&quot;&gt;&lt;/a&gt;1    原理&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;分水岭分割方法，是一种基于拓扑理论的数学形态学的分割方法，其基本思想是把图像看作是测地学上的拓扑地貌，图像中每一点像素的灰度值表示该点的海拔高度，每一个局部极小值及其影响区域称为集水盆，而集水盆的边界则形成分水岭。分水岭的概念和形成可以通过模拟浸入过程来说明。在每一个局部极小值表面，刺穿一个小孔，然后把整个模型慢慢浸入水中，随着浸入的加深，每一个局部极小值的影响域慢慢向外扩展，在两个集水盆汇合处构筑大坝，即形成分水岭。这种方法也称作泛洪法，对应的还有降雨法。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器视觉" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="opencv" scheme="https://aishangcengloua.github.io/tags/opencv/"/>
    
    <category term="图像分割" scheme="https://aishangcengloua.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——回溯算法的经典问题</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/LeetCode%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/LeetCode%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</id>
    <published>2022-06-05T11:05:50.000Z</published>
    <updated>2022-06-05T11:07:13.902Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;17-电话号码的字母组合&quot;&gt;&lt;a href=&quot;#17-电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;17. 电话号码的字母组合&quot;&gt;&lt;/a&gt;17. 电话号码的字母组合&lt;/h1&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/categories/Python/"/>
    
    <category term="数据结构与算法" scheme="https://aishangcengloua.github.io/categories/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://aishangcengloua.github.io/tags/Python/"/>
    
    <category term="数据结构与算法" scheme="https://aishangcengloua.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="https://aishangcengloua.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>KNN 算法实现图像分类</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/KNN-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/KNN-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</id>
    <published>2022-06-05T11:02:59.000Z</published>
    <updated>2022-06-05T11:04:59.718Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-scikit-learn介绍&quot;&gt;&lt;a href=&quot;#1-scikit-learn介绍&quot; class=&quot;headerlink&quot; title=&quot;1    scikit-learn介绍&quot;&gt;&lt;/a&gt;1    scikit-learn介绍&lt;/h1&gt;&lt;p&gt;scikit-learn与机器学习的关系：&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="传统算法" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="KNN" scheme="https://aishangcengloua.github.io/tags/KNN/"/>
    
    <category term="图像分类" scheme="https://aishangcengloua.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>对抗攻击</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB/</id>
    <published>2022-06-05T11:00:54.000Z</published>
    <updated>2022-06-05T11:01:48.998Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在人工智能带来的风险中，对抗攻击就是重要风险之一。攻击者可以通过各种手段绕过，或直接对机器学习模型进行攻击达到对抗目的，使我们的模型失效或误判。如果类似攻击发生在无人驾驶、金融AI等领域则将导致严重后果。所以，需要未雨绸缪，认识各种对抗攻击，并有效地破解各种对抗攻击。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://aishangcengloua.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对抗攻击" scheme="https://aishangcengloua.github.io/tags/%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>【OpenCv】图像的轮廓查找</title>
    <link href="https://aishangcengloua.github.io/2022/06/05/%E3%80%90OpenCv%E3%80%91%E5%9B%BE%E5%83%8F%E7%9A%84%E8%BD%AE%E5%BB%93%E6%9F%A5%E6%89%BE/"/>
    <id>https://aishangcengloua.github.io/2022/06/05/%E3%80%90OpenCv%E3%80%91%E5%9B%BE%E5%83%8F%E7%9A%84%E8%BD%AE%E5%BB%93%E6%9F%A5%E6%89%BE/</id>
    <published>2022-06-05T10:59:33.000Z</published>
    <updated>2022-06-05T11:02:26.287Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1    原理&quot;&gt;&lt;/a&gt;1    原理&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;边界或者轮廓可以简单认为成将连续的点（连着边界）连在一起的曲线，具有相同的颜色或者灰度。轮廓在形状分析和物体的检测和识别中很有用。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/b693a0ef9e12450f992dd8a7008c4d38.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;在机器视觉领域最常用的轮廓查找的算法之一是 &lt;strong&gt;&lt;em&gt;Moore-Neighbor&lt;/em&gt;&lt;/strong&gt; 算法，像素的摩尔邻域 $P$ 是与该像素共享顶点或边的 $8$ 个像素的集合。这些像素即 如下图所示的像素$P1$、$P2$、$P3$、$P4$、$P5$、$P6$、$P7$和$P8$。 摩尔邻域（也称为8 邻域或 间接邻域）是文献中经常出现的一个重要概念。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/7b438ebe573b4ad2940239b55e6eb119.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器视觉" scheme="https://aishangcengloua.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="opencv" scheme="https://aishangcengloua.github.io/tags/opencv/"/>
    
    <category term="轮廓检测" scheme="https://aishangcengloua.github.io/tags/%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
</feed>
